package org.lilbrocodes.constructive.internal.builder.generator;

import org.jetbrains.annotations.ApiStatus;
import org.lilbrocodes.constructive.internal.builder.model.ConstructiveClass;
import org.lilbrocodes.constructive.internal.builder.model.FieldModel;
import org.lilbrocodes.constructive.internal.builder.model.ImportModel;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

@ApiStatus.Internal
public final class BuilderEmitter {

    private BuilderEmitter() {}

    public static void emitHeader(StringBuilder sb, AtomicInteger importOffset, ConstructiveClass model, String builtType) {
        if (!model.packageName().isBlank()) {
            sb.append("package ").append(model.builderPackage()).append(";\n\n");
            importOffset.addAndGet(sb.length());
        }

        sb.append("/**\n")
                .append(" * Builder for {@link ").append(builtType).append("}. \n")
                .append(" * Class file generated by Constructor.\n")
                .append(" */\n");

        sb.append("public class ").append(model.builderName());
        if (model.needsWrapping()) sb.append("<P>");
        sb.append(" {\n");
        if (model.needsWrapping()) sb.append("    private final P parent;\n\n");
    }

    public static void emitFields(StringBuilder sb, Set<ImportModel> imports, ConstructiveClass model) {
        model.fields().stream()
                .filter(FieldModel::transientField)
                .forEach(field -> sb.append("    // @Transient field \"").append(field.name()).append("\" is ignored\n"));

        model.fields().stream()
                .filter(field -> !field.transientField())
                .forEach(field -> {
                    if (field.hasJavadoc()) {
                        sb.append("    /**\n");
                        if (field.description() != null) sb.append("     * ").append(field.description()).append("\n");
                        if (field.hardRequire()) sb.append("     * Required at creation time.\n");
                        if (!field.required() && !field.builder()) sb.append("     * This field is optional.\n");
                        if (field.defaultValueExpr() != null) sb.append("     * Default: ").append(field.defaultValueExpr()).append("\n");
                        sb.append("     */\n");
                    }

                    sb.append("    private ")
                            .append(ImportEmitter.resolveField(imports, model, field))
                            .append(" ").append(field.name());

                    if (field.hasDefault() || (field.builder() && !field.composite())) {
                        sb.append(" = ").append(
                                field.builder()
                                        ? DefaultResolver.resolveBuilder(imports, field, model.className(), model.builderPackage(), false)
                                        : DefaultResolver.resolve(imports, field, model.className(), model.builderPackage())
                        );
                    }

                    sb.append(";\n\n");
                });
    }

    public static void emitConstructor(StringBuilder sb, ConstructiveClass model) {
        sb.append("    private ").append(model.builderName()).append("(");
        if (model.needsWrapping()) sb.append("P parent");
        sb.append(") {\n");
        if (model.needsWrapping()) sb.append("        this.parent = parent;\n");
        sb.append("    }\n\n");
    }

    public static void emitCreateMethod(StringBuilder sb, Set<ImportModel> imports, ConstructiveClass model) {
        List<FieldModel> hardRequired = model.fields().stream()
                .filter(FieldModel::hardRequire)
                .toList();

        hardRequired.stream()
                .filter(FieldModel::builder)
                .forEach(field -> {
                    throw new IllegalArgumentException("@Builder is mutually exclusive with @HardRequired! Found both of them used at field '" + field.name() + "'.");
                });

        hardRequired.stream()
                .filter(FieldModel::composite)
                .forEach(field -> {
                    throw new IllegalArgumentException("@Composite is mutually exclusive with @HardRequired! Found both of them used at field '" + field.name() + "'.");
                });

        if (model.needsWrapping()) {
            sb.append("    public static <P> ").append(model.builderName()).append("<P> create(P parent");
            if (!hardRequired.isEmpty()) sb.append(", ");
        } else {
            sb.append("    public static ").append(model.builderName()).append(" create(");
        }

        sb.append(hardRequired.stream()
                .map(field -> ImportEmitter.resolveField(imports, model, field) + " " + field.name())
                .collect(Collectors.joining(", ")));
        sb.append(") {\n");

        hardRequired.stream()
                .filter(FieldModel::isNullable)
                .forEach(entry -> sb.append("        if (").append(entry.name()).append(" == null) {\n")
                        .append("            throw new IllegalArgumentException(\"HardRequire field '")
                        .append(entry.name()).append("' cannot be null\");\n")
                        .append("        }\n\n"));

        sb.append("        ").append(model.builderName()).append(" builder = new ")
                .append(model.builderName()).append("(").append(model.needsWrapping() ? "parent" : "").append(");\n");

        hardRequired.forEach(field -> sb.append("        builder.").append(field.name()).append(" = ").append(field.name()).append(";\n"));

        sb.append("        return builder;\n");
        sb.append("    }\n\n");

        if (model.needsWrapping()) {
            sb.append("    public static ").append(model.builderName()).append(" create(");
            sb.append(hardRequired.stream()
                    .map(field -> ImportEmitter.resolveField(imports, model, field) + " " + field.name())
                    .collect(Collectors.joining(", ")));
            sb.append(") {\n")
                    .append("        return create(null");
            if (!hardRequired.isEmpty()) sb.append(", ");
            sb.append(hardRequired.stream().map(FieldModel::name).collect(Collectors.joining(", "))).append(");\n")
                    .append("    }\n\n");
        }
    }

    public static void emitSetters(StringBuilder sb, Set<ImportModel> imports, ConstructiveClass model) {
        model.fields().stream()
                .filter(field -> !field.composite() && !field.builder() && !field.hardRequire() && !field.transientField())
                .forEach(field -> sb.append("    public ").append(model.builderName()).append(" ").append(field.name())
                        .append("(").append(ImportEmitter.resolveField(imports, model, field)).append(" ").append(field.name()).append(") {\n")
                        .append("        this.").append(field.name()).append(" = ").append(field.name()).append(";\n")
                        .append("        return this;\n")
                        .append("    }\n\n"));

        model.fields().stream()
                .filter(field -> !field.composite() && field.builder() && !field.transientField())
                .forEach(field -> sb.append("    public ").append(ImportEmitter.resolveField(imports, model, field)).append(" ").append(field.name())
                        .append("() {\n")
                        .append("        return this.").append(field.name()).append(";\n")
                        .append("    }\n\n"));

        model.fields().stream()
                .filter(field -> field.composite() && !field.builder() && !field.transientField())
                .forEach(field -> sb.append("    public ").append(ImportEmitter.resolveField(imports, model, field)).append(" ").append(field.name())
                        .append("(").append(field.hardRequired().entrySet().stream().map(
                                entry -> ImportEmitter.resolveType(imports, model, entry.getValue()) + " " + entry.getKey()
                        ).collect(Collectors.joining(", "))).append(") {\n        return ")
                        .append(ImportEmitter.resolveField(imports, model, field, false))
                        .append(".create(\n            this,\n            ")
                        .append(String.join(",\n            ", field.hardRequired().keySet()))
                        .append("\n        );\n    }\n\n")
                );
    }

    public static void emitBuildMethod(StringBuilder sb, Set<ImportModel> imports, ConstructiveClass model) {
        sb.append("    public ").append(model.className()).append(" build() {\n");

        model.fields().stream()
                .filter(field -> !field.hardRequire() && !field.hasDefault() && field.required() && !field.transientField() && field.isNullable())
                .forEach(field -> sb.append("        if (this.").append(field.name()).append(" == null) {\n")
                        .append("            throw new IllegalStateException(\"Required field '")
                        .append(field.name()).append("' was not set\");\n")
                        .append("        }\n"));

        model.fields().stream()
                .filter(field -> !field.hardRequire() && field.hasDefault() && field.required() && !field.transientField() && field.isNullable())
                .forEach(field -> sb.append("        if (this.").append(field.name()).append(" == null) {\n")
                        .append("            this.").append(field.name()).append(" = ")
                        .append(DefaultResolver.resolve(imports, field, model.className(), model.builderPackage())).append(";\n")
                        .append("        }\n\n"));

        sb.append("        return new ").append(model.className()).append("(");
        sb.append(model.fields().stream()
                .filter(field -> !field.transientField())
                .map(FieldModel::make)
                .collect(Collectors.joining(", ")));
        sb.append(");\n    }\n\n");
    }

    public static void emitResetMethod(StringBuilder sb, Set<ImportModel> imports, ConstructiveClass model) {
        sb.append("    public ").append(model.builderName()).append(" reset() {\n");
        model.fields().stream()
                .filter(field -> !field.hardRequire() && !field.transientField())
                .forEach(field -> {
                    sb.append("        this.").append(field.name()).append(" = ");
                    sb.append(field.builder()
                            ? DefaultResolver.resolveBuilder(imports, field, model.className(), model.builderPackage(), true)
                            : DefaultResolver.resolve(imports, field, model.className(), model.builderPackage()));
                    sb.append(";\n");
                });
        sb.append("\n        return this;\n    }\n\n");
    }

    public static void emitEndMethod(StringBuilder sb, ConstructiveClass model) {
        if (model.needsWrapping()) {
            sb.append("    public P end() {\n")
                    .append("        if (parent == null) {\n")
                    .append("            throw new IllegalStateException(\"Cannot call end on a root builder!\");\n")
                    .append("        }\n")
                    .append("        return parent;\n")
                    .append("    }\n");
        }
        sb.append("}\n");
    }
}
